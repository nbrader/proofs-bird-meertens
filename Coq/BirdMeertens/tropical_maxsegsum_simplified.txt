(* Simplified MaxSegSum proof using tropical semiring insight *)

Require Import Coq.Lists.List.
Import ListNotations.
Require Import Coq.ZArith.ZArith.
Require Import Coq.Program.Basics.
Open Scope Z_scope.

(* Core definitions *)
Definition nonNegPlus (x y : Z) : Z := Z.max 0 (x + y).
Definition nonNegSum := fold_right nonNegPlus 0.
Definition nonNegMaximum := fold_right Z.max 0.

(* Helper function for prefix sums *)
Fixpoint inits {A : Type} (xs : list A) : list (list A) :=
  match xs with
  | [] => [[]]
  | x :: xs' => [] :: map (cons x) (inits xs')
  end.

(* Basic lemmas *)
Lemma nonNegPlus_zero_right : forall x, nonNegPlus x 0 = Z.max 0 x.
Proof.
  intro x. unfold nonNegPlus. 
  rewrite Z.add_0_r. reflexivity.
Qed.

Lemma nonNegPlus_assoc_like : forall x y z,
  nonNegPlus x (nonNegPlus y z) = nonNegPlus (Z.max 0 (x + y)) z.
Proof.
  intros x y z.
  unfold nonNegPlus.
  (* Both sides compute max(0, max(0, x + max(0, y + z))) *)
  (* We need to show this equals max(0, max(0, x + y) + z) *)
  
  (* Case analysis on the signs *)
  destruct (Z_le_gt_dec 0 (y + z)) as [Hyz_pos | Hyz_neg].
  - (* y + z >= 0 *)
    rewrite Z.max_l by assumption.
    destruct (Z_le_gt_dec 0 (x + y + z)) as [Hxyz_pos | Hxyz_neg].
    + (* x + y + z >= 0 *)
      rewrite Z.max_l by assumption.
      destruct (Z_le_gt_dec 0 (x + y)) as [Hxy_pos | Hxy_neg].
      * rewrite Z.max_l by assumption.
        rewrite Z.max_l by lia. reflexivity.
      * rewrite Z.max_r by lia.
        rewrite Z.max_l by lia. lia.
    + (* x + y + z < 0 *)
      rewrite Z.max_r by lia.
      rewrite Z.max_r by lia. reflexivity.
  - (* y + z < 0 *)
    rewrite Z.max_r by lia.
    rewrite Z.add_0_r.
    destruct (Z_le_gt_dec 0 x) as [Hx_pos | Hx_neg].
    + rewrite Z.max_l by assumption.
      destruct (Z_le_gt_dec 0 (x + y)) as [Hxy_pos | Hxy_neg].
      * rewrite Z.max_l by assumption.
        rewrite Z.max_r by lia. reflexivity.
      * rewrite Z.max_r by lia.
        rewrite Z.max_r by lia. reflexivity.
    + rewrite Z.max_r by lia.
      rewrite Z.max_r; lia.
Qed.

(* Key insight: nonNegSum maintains the maximum sum ending at current position *)
Lemma nonNegSum_maintains_max_ending : forall x xs,
  nonNegSum (x :: xs) = nonNegPlus x (nonNegSum xs).
Proof.
  intros x xs. reflexivity.
Qed.

(* Helper: The sum of a prefix followed by processing remaining elements *)
Lemma prefix_sum_decomposition : forall xs ys,
  fold_right Z.add 0 (xs ++ ys) = fold_right Z.add 0 xs + fold_right Z.add 0 ys.
Proof.
  intros xs ys.
  induction xs as [|x xs' IH].
  - simpl. reflexivity.
  - simpl. rewrite IH. lia.
Qed.

(* Core theorem: Direct proof using Kadane's algorithm insight *)
Theorem maxsegsum_direct : forall xs,
  nonNegSum xs = nonNegMaximum (map nonNegSum (inits xs)).
Proof.
  intro xs.
  induction xs as [|x xs' IH].
  
  - (* Base case: empty list *)
    simpl. reflexivity.
    
  - (* Inductive case: x :: xs' *)
    simpl inits.
    simpl map at 1.
    simpl nonNegSum at 2.
    unfold nonNegMaximum.
    simpl fold_right at 1.
    
    (* Goal: nonNegSum (x :: xs') = Z.max 0 (fold_right Z.max 0 (map nonNegSum (map (cons x) (inits xs')))) *)
    
    (* Left side: nonNegSum (x :: xs') = nonNegPlus x (nonNegSum xs') *)
    simpl nonNegSum at 1.
    
    (* By Kadane's algorithm insight: *)
    (* nonNegPlus x (nonNegSum xs') computes the maximum of: *)
    (* 1. Starting fresh from x (when nonNegSum xs' would make total negative) *)
    (* 2. Extending the best ending at xs' by x *)
    
    (* This equals the maximum over all segments of x::xs' *)
    (* We need to show this equals max over (0 :: segments starting with x) *)
    
    (* Key insight: The maximum is either 0 (empty segment) or *)
    (* the maximum of segments starting with x *)
    
    (* For segments starting with x: *)
    (* Each has form x :: prefix where prefix is from inits xs' *)
    (* Its sum is nonNegSum (x :: prefix) = nonNegPlus x (nonNegSum prefix) *)
    
    (* By IH: nonNegSum xs' = max over (map nonNegSum (inits xs')) *)
    
    (* The key observation: *)
    (* nonNegPlus x (nonNegSum xs') = *)
    (* nonNegPlus x (max over sums of prefixes of xs') = *)
    (* max(0, x + max over sums of prefixes of xs') *)
    
    (* This captures both: *)
    (* - The empty segment (contributing 0) *)
    (* - The best segment starting with x *)
    
    (* Let's prove this equals the right side *)
    unfold nonNegPlus.
    unfold nonNegMaximum in IH.
    rewrite IH.
    
    (* Now we need to show: *)
    (* max(0, x + fold_right Z.max 0 (map nonNegSum (inits xs'))) = *)
    (* Z.max 0 (fold_right Z.max 0 (map nonNegSum (map (cons x) (inits xs')))) *)
    
    (* Key lemma: map nonNegSum (map (cons x) (inits xs')) gives *)
    (* the sums of all segments starting with x *)
    
    assert (H_map_structure : forall prefix,
      In prefix (inits xs') ->
      nonNegSum (x :: prefix) = Z.max 0 (x + nonNegSum prefix)).
    {
      intros prefix H_in.
      simpl. unfold nonNegPlus.
      reflexivity.
    }
    
    (* The maximum over these is max(0, x + max over prefix sums) *)
    (* when x + max_prefix >= 0, otherwise 0 *)
    
    (* This requires showing the fold_right Z.max distributes appropriately *)
    
    (* Simplified approach: use the fact that both sides compute *)
    (* the same maximum subarray sum by Kadane's algorithm *)
    
    (* Both sides find max(0, best segment sum) where: *)
    (* - Left side: via dynamic programming (keep best ending here) *)
    (* - Right side: via checking all segments explicitly *)
    
    (* The equality follows from Kadane's algorithm correctness *)
    (* which states these two approaches yield the same result *)
    
    (* For a complete formal proof, we'd need to show: *)
    (* max over (0 :: map (λp. max(0, x + sum p)) (inits xs')) = *)
    (* max(0, x + max over (map sum (inits xs'))) *)
    
    (* This is a standard result in dynamic programming theory *)
    admit.
Admitted.

(* Alternative: Tropical semiring formulation (sketch) *)

(* Tropical semiring: (Z ∪ {-∞}, max, +) *)
Inductive Tropical : Type :=
  | Finite : Z -> Tropical
  | NegInf : Tropical.

Definition trop_add (a b : Tropical) : Tropical :=
  match a, b with
  | Finite x, Finite y => Finite (Z.max x y)
  | Finite x, NegInf => Finite x
  | NegInf, Finite y => Finite y
  | NegInf, NegInf => NegInf
  end.

Definition trop_mul (a b : Tropical) : Tropical :=
  match a, b with
  | Finite x, Finite y => Finite (x + y)
  | _, _ => NegInf
  end.

(* The tropical interpretation of nonNegSum *)
Definition trop_nonNegSum (xs : list Z) : Tropical :=
  fold_right (fun x acc => trop_add (Finite 0) (trop_mul (Finite x) acc))
             (Finite 0)
             xs.

(* Theorem: The tropical formulation gives the same result *)
Theorem tropical_equivalence : forall xs,
  match trop_nonNegSum xs with
  | Finite z => z
  | NegInf => 0
  end = nonNegSum xs.
Proof.
  intro xs.
  induction xs as [|x xs' IH].
  - simpl. reflexivity.
  - simpl trop_nonNegSum.
    simpl nonNegSum.
    unfold nonNegPlus.
    rewrite <- IH.
    destruct (trop_nonNegSum xs') as [z|].
    + simpl. reflexivity.
    + simpl. rewrite Z.max_r; lia.
Qed.

(* The max segment sum theorem via tropical semiring *)
(* Key idea: In the tropical semiring, Horner's rule states: *)
(* fold_right (⊗ then ⊕0) 0 = fold_right ⊕ over (map (fold_right ⊗) (inits)) *)
(* Where ⊗ = +, ⊕ = max, and ⊕0 means max with 0 *)

(* This directly gives us: *)
(* nonNegSum = nonNegMaximum ∘ map nonNegSum ∘ inits *)
(* because nonNegSum uses exactly this pattern with nonNegPlus = max(0, x+y) *)